<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
   <title>Библиотека Tkinter</title>
   <link rel="stylesheet" href="css/xt256.min.css">
   <link rel="stylesheet" href="css/styles.css">
   <script src="css/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
</head>
<body>

<p><strong><em><a href="index.html">Главная</a></em></strong></p>

<hr />

<h2>50.2. карты стилей ttk: динамическое изменение внешнего вида</h2>

<p>Виджеты <em>ttk</em> могут менять свой внешний вид во время выполнения программы. Например, когда виджет находится в состоянии <em>disabled</em>, он не реагирует на действия мыши или клавиатуры. Обычно отключенный виджет имеет другой внешний вид, чтобы пользователь мог понять, что виджет не будет реагировать на мышь.</p>

<p>В целом, каждый виджет <em>ttk</em> имеет набор <em>флагов состояния</em>, которые можно использовать для изменения внешнего вида виджета во время выполнения. Каждое состояние может быть <em>установлено</em> (включено) или <em>сброшено</em> (выключено) независимо от других состояний. Состояния и их значения:</p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>active</code></td>
  <td>В данный момент мышь находится в виджете.</td>
</tr>
<tr>
  <td><code>alternate</code></td>
  <td>Это состояние зарезервировано для использования приложением.</td>
</tr>
<tr>
  <td><code>background</code></td>
  <td>В Windows или MacOS виджет находится в окне, которое не является окном переднего плана.</td>
</tr>
<tr>
  <td><code>disabled</code></td>
  <td>Виджет не будет реагировать на действия пользователя.</td>
</tr>
<tr>
  <td><code>focus</code></td>
  <td>Виджет в настоящее время имеет <a href="focus.html">фокус</a>.</td>
</tr>
<tr>
  <td><code>invalid</code></td>
  <td>Содержимое виджета в настоящее время недействительно.</td>
</tr>
<tr>
  <td><code>pressed</code></td>
  <td>Виджет в данный момент нажат (например, кнопка, на которую нажимают).</td>
</tr>
<tr>
  <td><code>readonly</code></td>
  <td>Виджет не позволяет никаким действиям пользователя изменять его текущее значение. Например, виджет <em>Entry</em>, доступный только для чтения, не позволит редактировать его содержимое.</td>
</tr>
<tr>
  <td><code>selected</code></td>
  <td>Виджет выбран. Примером могут служить чекбаттоны и радиобаттоны, находящиеся в состоянии "включено".</td>
</tr>
</tbody>
</table>

<p>Некоторые состояния изменяются в ответ на действия пользователя, например, состояние <code>pressed</code> кнопки. Ваша программа может опросить, очистить или установить любое состояние с помощью функций, описанных в <a href="ttk-Widget.html">разделе 46, "Методы, общие для всех виджетов ttk"</a>.</p>

<p>Логика, изменяющая внешний вид виджета, привязана к одному из его элементов. Чтобы опросить или настроить динамическое поведение для определенного стиля, для экземпляра <code>s</code> из <code>ttk.Style</code>, используйте этот метод, где <code>styleName</code> - имя элемента, например, <code>'Button.label'</code> или <code>'border'</code>.</p>

<pre><code>s.map(styleName, *p, **kw)
</code></pre>

<p>Чтобы определить динамическое поведение одной из опций данного элемента стиля, передайте имя опции в качестве второго позиционного аргумента, и метод вернет список спецификаций изменения состояния.</p>

<p>Каждая спецификация изменения состояния представляет собой последовательность <code>(s0, s1, n)</code>. Эта последовательность означает, что когда текущее состояние виджета соответствует всем элементам <code>si</code>, для опции устанавливается значение <code>n</code>. Каждый элемент <code>si</code> - это либо имя состояния, либо имя состояния, которому предшествует символ "<code>!</code>". Чтобы виджет соответствовал, он должен находиться во всех состояниях, описанных элементами, которые не начинаются с "<code>!</code>", и <em>не</em> должен находиться ни в одном из состояний, начинающихся с "<code>!</code>".</p>

<p>Например, предположим, что у вас есть экземпляр <code>s</code> класса <code>ttk.Style</code>, и вы вызываете его следующим образом:</p>

<pre><code>changes = s.map('TCheckbutton', 'indicatorcolor')
</code></pre>

<p>Далее предположим, что возвращаемое значение будет:</p>

<pre><code>[('pressed', '#ececec'), ('selected', '#4a6984')]
</code></pre>

<p>Это означает, что когда <em>checkbutton</em> находится в состоянии <code>pressed</code>, его опция <code>indicatorcolor</code> должна быть установлена на цвет <code>'#ececec'</code>, а когда <em>checkbutton</em> находится в состоянии <code>selected</code>, его опция <code>indicatorcolor</code> должна быть установлена на <code>'#4a6984'</code>.</p>

<p>Вы также можете изменить динамическое поведение элемента, передав методу <code>.map()</code> один или несколько аргументов в виде ключевых слов. Например, чтобы получить поведение, описанное в примере выше, используйте этот вызов метода:</p>

<pre><code>s.map('TCheckbutton',
    indicatoron=[('pressed', '#ececec'), ('selected', '#4a6984')])
</code></pre>

<p>А вот более сложный пример. Предположим, вы хотите создать собственный стиль кнопки на основе стандартного класса <code>TButton</code>. Мы назовем наш стиль <code>Wild.TButton</code>; поскольку наше имя заканчивается на "<code>.TButton</code>", он автоматически наследует стандартные возможности стиля. Вот как настроить этот новый стиль:</p>

<pre><code>s = ttk.Style()
s.configure('Wild.TButton',
    background='black',
    foreground='white',
    highlightthickness='20',
    font=('Helvetica', 18, 'bold'))
s.map('Wild.TButton',
    foreground=[('disabled', 'yellow'),
                ('pressed', 'red'),
                ('active', 'blue')],
    background=[('disabled', 'magenta'),
                ('pressed', '!focus', 'cyan'),
                ('active', 'green')],
    highlightcolor=[('focus', 'green'),
                    ('!focus', 'red')],
    relief=[('pressed', 'groove'),
            ('!pressed', 'ridge')])
</code></pre>

<ul>
<li><p>Изначально эта кнопка будет отображать белый текст на черном фоне, с выделением фокуса шириной 20 пикселей.</p></li>
<li><p>Если кнопка находится в состоянии <code>'disabled'</code>, она будет отображать желтый текст на пурпурном фоне.</p></li>
<li><p>Если кнопка в данный момент нажата, текст будет красным; если кнопка не имеет фокуса, фон будет голубым. Кортеж <code>('pressed', '!focus', 'cyan')</code> - это пример того, как можно сделать атрибут зависимым от комбинации состояний.</p></li>
<li><p>Если кнопка активна (находится под курсором), текст будет синим на зеленом фоне.</p></li>
<li><p>Выделение фокуса будет зеленым, если кнопка имеет фокус, и красным, если не имеет.</p></li>
<li><p>Кнопка будет иметь рельеф в виде гребня, когда она не нажата, и рельеф в виде канавки, когда она нажата.</p></li>
</ul>

<hr />

<p><strong><em><a href="connecting.html">&gt;&gt; Подключение логики приложения к виджетам</a></em></strong></p>

</body>
</html>
