<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
   <title>Библиотека Tkinter</title>
   <link rel="stylesheet" href="css/xt256.min.css">
   <link rel="stylesheet" href="css/styles.css">
   <script src="css/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
</head>
<body>

<p><strong><em><a href="index.html">Главная</a></em></strong></p>

<hr />

<h2>24.8. Методы для виджетов Text</h2>

<p>Эти методы доступны для всех текстовых виджетов:</p>

<p><code>.bbox(index)</code></p>

<blockquote>
  <p>Возвращает ограничивающую рамку для символа с заданным индексом, представляющую собой 4-кортеж <code>(x, y, width, height)</code>. Если символ не виден, возвращается <code>None</code>. Обратите внимание, что этот метод может не вернуть точное значение, если вы не вызовете метод <code>.update_idletasks()</code> (см. <a href="universal.html">Раздел 26, " Универсальные методы виджетов"</a>).</p>
</blockquote>

<p><code>.compare(index1, op, index2)</code></p>

<blockquote>
  <p>Сравнивает позиции двух индексов в текстовом виджете и возвращает true, если между <code>index1</code> и <code>index2</code> выполняется соотношение <code>op</code>. Параметр <code>op</code> указывает, какое сравнение использовать, одно из: <code>'&lt;'</code>, <code>'&lt;='</code>, <code>'=='</code>, <code>'!='</code>, <code>'&gt;='</code>, или <code>'&gt;'</code>.</p>
</blockquote>

<blockquote>
  <p>Например, для текстового виджета <code>t</code>, <code>t.compare('2.0', '&lt;=', END)</code> возвращает <em>истину</em>, если начало второй строки находится перед или в конце текста в <code>t</code>.</p>
</blockquote>

<p><code>.delete(index1, index2=None)</code></p>

<blockquote>
  <p>Удаляет текст, начинающийся сразу после <code>index1</code>. Если второй аргумент опущен, удаляется только один символ. Если указан второй индекс, удаление продолжается до символа после <code>index2</code>, но не включая его. Напомним, что индексы располагаются <em>между</em> символами.</p>
</blockquote>

<p><code>.dlineinfo(index)</code></p>

<blockquote>
  <p>Возвращает ограничительную рамку для строки, содержащей заданный <code>index</code>. О форме границы и предостережении по поводу обновления неработающих задач см. определение метода <code>.bbox</code> выше.</p>
</blockquote>

<p><code>.edit_modified(arg=None)</code></p>

<blockquote>
  <p>Запрашивает, устанавливает или снимает флаг <em>modified</em>. Этот флаг используется для отслеживания того, было ли изменено содержимое виджета. Например, если вы реализуете текстовый редактор в виджете <em>Text</em>, вы можете использовать флаг <em>modified</em>, чтобы определить, изменилось ли его содержимое с момента последнего сохранения в файл.</p>
</blockquote>

<blockquote>
  <p>При вызове без аргумента этот метод возвращает <code>True</code>, если флаг <em>modified</em> был установлен, и <code>False</code>, если он не установлен. Вы также можете явно установить флаг <em>modified</em>, передав этому методу значение <code>True</code>, или снять его, передав значение <code>False</code>.</p>
</blockquote>

<blockquote>
  <p>Любая операция, вставляющая или удаляющая текст, будь то действия программы или пользователя, а также операция отмены/возврата, установит флаг модификации.</p>
</blockquote>

<p><code>.edit_redo()</code></p>

<blockquote>
  <p>Выполняет операцию повторного редактирования. Подробнее см. в <a href="text-undo-stack.html">Раздел 24.7, "Стек отмены/возврата виджета Text"</a>.</p>
</blockquote>

<p><code>.edit_reset()</code></p>

<blockquote>
  <p>Очищает стек отмены.</p>
</blockquote>

<p><code>.edit_separator()</code></p>

<blockquote>
  <p>Помещает разделитель в стек отмены. Этот разделитель ограничивает область действия будущей операции отмены только теми изменениями, которые были внесены с момента внесения разделителя. Подробнее см. в <a href="text-undo-stack.html">Раздел 24.7, "Стек отмены/возврата виджета Text"</a>.</p>
</blockquote>

<p><code>.edit_undo()</code></p>

<blockquote>
  <p>Отменяет все изменения содержимого виджета, сделанные с тех пор, как последний разделитель был помещен в стек отмены, или до самого низа стека, если стек не содержит разделителей. Подробнее см. в <a href="text-undo-stack.html">Раздел 24.7, "Стек отмены/возврата виджета Text"</a>. Если стек отмены пуст, то это ошибка.</p>
</blockquote>

<p><code>.image_create(index[, option=value, ...])</code></p>

<blockquote>
  <p>Этот метод вставляет изображение в виджет. Изображение рассматривается как еще один символ, размер которого равен естественному размеру изображения.</p>
</blockquote>

<blockquote>
  <p>Опции для этого метода приведены в таблице ниже. Вы можете передать либо серию аргументов <code>option=value</code>, либо словарь имен и значений опций.</p>
</blockquote>

<blockquote>
  <table>
  <thead>
  <tr>
    <th></th>
    <th></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>align</code></td>
    <td>Эта опция определяет, как изображение должно быть выровнено по вертикали, если его высота меньше высоты содержащей его строки. Значениями могут быть <code>top</code> для выравнивания по верхней части пространства; <code>center</code> для выравнивания по центру; <code>bottom</code> для размещения изображения внизу; или <code>baseline</code> для выравнивания нижней части изображения по базовой линии текста.</td>
  </tr>
  <tr>
    <td><code>image</code></td>
    <td>Используемое изображение. См. <a href="images.html">Раздел 5.9, "Изображения"</a>.</td>
  </tr>
  <tr>
    <td><code>name</code></td>
    <td>Вы можете присвоить имя данному экземпляру изображения. Если вы опустите этот параметр, Tkinter сгенерирует уникальное имя. Если вы создадите несколько экземпляров изображения в одном виджете <em>Text</em>, Tkinter сгенерирует уникальное имя, добавив к нему знак "<code>#</code>", за которым последует число.</td>
  </tr>
  <tr>
    <td><code>padx</code></td>
    <td>Если задано, то эта опция представляет собой количество пикселей дополнительного пространства, которое будет добавлено с обеих сторон изображения.</td>
  </tr>
  <tr>
    <td><code>pady</code></td>
    <td>Если задано, эта опция представляет собой количество пикселей дополнительного пространства, которое будет добавлено над и под изображением.</td>
  </tr>
  </tbody>
  </table>
</blockquote>

<p><code>.get(index1, index2=None)</code></p>

<blockquote>
  <p>Используйте этот метод для получения текущего текста из виджета. Получение начинается с индекса <code>index1</code>. Если второй аргумент опущен, вы получаете символ после <code>index1</code>. Если вы укажете второй индекс, вы получите текст между этими двумя индексами. Встроенные изображения и окна (виджеты) игнорируются. Если диапазон включает несколько строк, они разделяются символами новой строки (<code>'\n'</code>).</p>
</blockquote>

<p><code>.image_cget(index, option)</code></p>

<blockquote>
  <p>Чтобы получить текущее значение опции, установленной на встроенном изображении, вызовите этот метод с индексом, указывающим на изображение, и именем опции.</p>
</blockquote>

<p><code>.image_configure(index, option, ...)</code></p>

<blockquote>
  <p>Чтобы установить одну или несколько опций для встроенного изображения, вызовите этот метод с индексом, указывающим на изображение в качестве первого аргумента, и одной или несколькими парами <code>option=value</code>.</p>
</blockquote>

<blockquote>
  <p>Если вы не укажете никаких опций, вы получите словарь, определяющий все опции изображения и соответствующие им значения.</p>
</blockquote>

<p><code>.image_names()</code></p>

<blockquote>
  <p>Этот метод возвращает кортеж имен всех встроенных изображений текстового виджета.</p>
</blockquote>

<p><code>.index(i)</code></p>

<blockquote>
  <p>Для индекса <code>i</code> этот метод возвращает эквивалентную позицию в формате <code>'line.char'</code>.</p>
</blockquote>

<p><code>.insert(index, text, tags=None)</code></p>

<blockquote>
  <p>Вставляет заданный <code>text</code> по заданному <code>index</code>.</p>
</blockquote>

<blockquote>
  <p>Если вы опустите аргумент <code>tags</code>, новый вставленный текст будет помечен любыми тегами, которые применяются к символам <em>как</em> до, так и после позиции вставки.</p>
</blockquote>

<blockquote>
  <p>Если вы хотите применить один или несколько тегов к вставляемому тексту, укажите в качестве третьего аргумента кортеж строк тегов. Любые теги, применяемые к существующим символам вокруг позиции вставки, игнорируются.</p>
</blockquote>

<blockquote>
  <ul>
  <li><strong>Примечание:</strong> Третий аргумент должен быть кортежем. Если вы укажете аргумент в виде списка, Tkinter не сможет применить теги. Если вы предоставите строку, каждый символ будет рассматриваться как тег.</li>
  </ul>
</blockquote>

<p><code>.mark_gravity(mark, gravity=None)</code></p>

<blockquote>
  <p>Изменяет или запрашивает гравитацию существующей метки; объяснение гравитации см. в <a href="text-mark.html">Раздел 24.2, "Метки виджета Text"</a>, выше.</p>
</blockquote>

<blockquote>
  <p>Чтобы задать гравитацию, введите имя метки, а затем либо <code>tk.LEFT</code>, либо <code>tk.RIGHT</code>. Чтобы узнать гравитацию существующей метки, опустите второй аргумент, и метод вернет <code>tk.LEFT</code> или <code>tk.RIGHT</code>.</p>
</blockquote>

<p><code>.mark_names()</code></p>

<blockquote>
  <p>Возвращает последовательность имен всех меток в окне, включая <code>tk.INSERT</code> и <code>tk.CURRENT</code>.</p>
</blockquote>

<p><code>.mark_next(index)</code></p>

<blockquote>
  <p>Возвращает имя метки, следующей за заданным <code>index</code>; если следующих меток нет, метод возвращает пустую строку.</p>
</blockquote>

<blockquote>
  <p>Если <code>index</code> имеет числовой вид, метод возвращает первую метку на этой позиции. Если <code>index</code> - это метка, то метод возвращает следующую за ней метку, которая может находиться в той же числовой позиции.</p>
</blockquote>

<p><code>.mark_previous(index)</code></p>

<blockquote>
  <p>Возвращает имя метки, предшествующей заданному <code>index</code>. Если предшествующих меток нет, метод возвращает пустую строку.</p>
</blockquote>

<blockquote>
  <p>Если <code>index</code> имеет числовой вид, метод возвращает последнюю метку на этой позиции. Если <code>index</code> - это метка, то метод возвращает предыдущую метку, которая может находиться в той же числовой позиции.</p>
</blockquote>

<p><code>.mark_set(mark, index)</code></p>

<blockquote>
  <p>Если метка с именем <code>mark</code> не существует, то она создается с помощью гравитации <code>tk.RIGHT</code> и помещается туда, куда указывает <code>index</code>. Если метка уже существует, она перемещается в новое место.</p>
</blockquote>

<blockquote>
  <p>Этот метод может изменить положение индексов <code>tk.INSERT</code> или <code>tk.CURRENT</code>.</p>
</blockquote>

<p><code>.mark_unset(mark)</code></p>

<blockquote>
  <p>Удаляет именованную метку. Этот метод не может быть использован для удаления меток <code>tk.INSERT</code> или <code>tk.CURRENT</code>.</p>
</blockquote>

<p><code>.scan_dragto(x, y)</code></p>

<blockquote>
  <p>Смотрите <code>.scan_mark</code>, ниже.</p>
</blockquote>

<p><code>.scan_mark(x, y)</code></p>

<blockquote>
  <p>Этот метод используется для реализации быстрой прокрутки виджета <em>Text</em>. Обычно пользователь нажимает и удерживает кнопку мыши в некоторой позиции виджета, а затем перемещает мышь в нужном направлении, и виджет перемещается в этом направлении со скоростью, пропорциональной расстоянию, на которое переместилась мышь с момента нажатия кнопки. Движение может представлять собой любую комбинацию вертикальной или горизонтальной прокрутки.</p>
</blockquote>

<blockquote>
  <p>Чтобы реализовать эту функцию, привяжите событие нажатия кнопки мыши к обработчику, который вызывает <code>.scan_mark(x, y)</code>, где <code>x</code> и <code>y</code> - текущее положение мыши. Затем привяжите событие <code>&lt;Motion&gt;</code> к обработчику, который вызывает <code>.scan_dragto(x, y)</code>, где <code>x</code> и <code>y</code> - новое положение мыши.</p>
</blockquote>

<p><code>.search(pattern, index, option, ...)</code></p>

<blockquote>
  <p>Ищет шаблон <code>pattern</code> (который может быть как строкой, так и регулярным выражением) в буфере, начиная с заданного индекса <code>index</code>. В случае успеха возвращается индекс в виде <code>'line.char'</code>, в случае неудачи - пустая строка.</p>
</blockquote>

<blockquote>
  <p>Допустимыми опциями для этого метода являются:</p>
</blockquote>

<blockquote>
  <table>
  <thead>
  <tr>
    <th></th>
    <th></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>backwards</code></td>
    <td>Установите этот параметр в <code>True</code> для поиска в обратном направлении от индекса. По умолчанию активирована опция <code>forwards</code>.</td>
  </tr>
  <tr>
    <td><code>count</code></td>
    <td>Если вы установите этот параметр в управляющую переменную <code>IntVar</code>, то при совпадении вы сможете получить длину текста, который совпал, используя метод <code>.get()</code> для этой переменной после возврата метода.</td>
  </tr>
  <tr>
    <td><code>exact</code></td>
    <td>Установите этот параметр в <code>True</code> для поиска текста, который точно соответствует <code>pattern</code>. Эта опция используется по умолчанию. Сравните с опцией <code>regexp</code> ниже.</td>
  </tr>
  <tr>
    <td><code>forwards</code></td>
    <td>Установите этот параметр в значение <code>True</code> для поиска вперед от индекса. Эта опция используется по умолчанию.</td>
  </tr>
  <tr>
    <td><code>regexp</code></td>
    <td>Установите этот параметр в значение <code>True</code>, чтобы интерпретировать <code>pattern</code> как регулярное выражение в стиле Tcl. По умолчанию используется поиск точного совпадения с <code>pattern</code>. Регулярные выражения Tcl являются подмножеством регулярных выражений Python и поддерживают следующие возможности: <pre><code>. ^ [c1…] (…) * + ? e1&vert;e2</code></pre></td>
  </tr>
  <tr>
    <td><code>nocase</code></td>
    <td>Установите этот параметр в 1, чтобы игнорировать регистр. По умолчанию используется поиск с учетом регистра.</td>
  </tr>
  <tr>
    <td><code>stopindex</code></td>
    <td>Чтобы ограничить поиск, установите этот параметр на индекс, за пределы которого поиск не должен выходить.</td>
  </tr>
  </tbody>
  </table>
</blockquote>

<p><code>.see(index)</code></p>

<blockquote>
  <p>Если текст, содержащий заданный индекс, не виден, прокрутите текст до тех пор, пока он не станет виден.</p>
</blockquote>

<p><code>.tag_add(tagName, index1, index2=None)</code></p>

<blockquote>
  <p>Этот метод связывает тег с именем <code>tagName</code> с областью содержимого, начинающейся сразу после индекса <code>index1</code> и продолжающейся до индекса <code>index2</code>. Если опустить <code>index2</code>, то тегами будет отмечен только символ после <code>index1</code>.</p>
</blockquote>

<p><code>.tag_bind(tagName, sequence, func, add=None)</code></p>

<blockquote>
  <p>Этот метод связывает событие со всем текстом, помеченным <code>tagName</code>. Дополнительные сведения о привязках событий см. в <a href="events.html">разделе 54, "События"</a>, ниже.</p>
</blockquote>

<blockquote>
  <p>Чтобы создать новую привязку для текста с тегами, используйте первые три аргумента: <code>sequence</code> указывает на событие, а <code>func</code> - это функция, которую вы хотите вызвать при наступлении этого события.</p>
</blockquote>

<blockquote>
  <p>Чтобы добавить другую привязку к существующему тегу, передайте те же первые три аргумента и <code>'+'</code> в качестве четвертого аргумента.</p>
</blockquote>

<blockquote>
  <p>Чтобы узнать, какие привязки существуют для данной последовательности в теге, передайте только первые два аргумента; метод вернет связанную функцию.</p>
</blockquote>

<blockquote>
  <p>Чтобы найти все привязки для заданного тега, передайте только первый аргумент; метод возвращает список всех аргументов <code>sequence</code> тега.</p>
</blockquote>

<p><code>.tag_cget(tagName, option)</code></p>

<blockquote>
  <p>Используйте этот метод для получения значения заданной опции <code>option</code> для заданного имени тега <code>tagName</code>.</p>
</blockquote>

<p><code>.tag_config(tagName, option, ...)</code></p>

<blockquote>
  <p>Чтобы изменить значение опций для тега с именем <code>tagName</code>, передайте одну или несколько пар <code>option=value</code>.</p>
</blockquote>

<blockquote>
  <p>Если вы передадите только один аргумент, вы получите словарь, определяющий все опции и их значения, действующие в данный момент для именованного тега.</p>
</blockquote>

<blockquote>
  <p>Вот опции для настройки тега:</p>
</blockquote>

<blockquote>
  <table>
  <thead>
  <tr>
    <th></th>
    <th></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>background</code></td>
    <td>Цвет фона для текста с этим тегом. Обратите внимание, что вы не можете использовать <code>bg</code> в качестве аббревиатуры.</td>
  </tr>
  <tr>
    <td><code>bgstipple</code></td>
    <td>Чтобы фон казался сероватым, установите этот параметр в одно из стандартных имен битмапов (см. <a href="bitmaps.html">Раздел 5.7, "Битовые изображения"</a>). Это не имеет никакого эффекта, если вы также не укажете <code>background</code>.</td>
  </tr>
  <tr>
    <td><code>borderwidth</code></td>
    <td>Ширина границы вокруг текста с этим тегом. По умолчанию <code>0</code>. Обратите внимание, что вы не можете использовать <code>bd</code> в качестве аббревиатуры.</td>
  </tr>
  <tr>
    <td><code>fgstipple</code></td>
    <td>Чтобы текст выглядел сероватым, установите этот параметр как <a href="bitmaps.html">имя битмапа</a>.</td>
  </tr>
  <tr>
    <td><code>font</code></td>
    <td>Шрифт, используемый для отображения текста с этим тегом. См. <a href="fonts.html">Раздел 5.4, "Шрифты"</a>.</td>
  </tr>
  <tr>
    <td><code>foreground</code></td>
    <td>Цвет, используемый для текста с этим тегом. Обратите внимание, что здесь нельзя использовать аббревиатуру <code>fg</code>.</td>
  </tr>
  <tr>
    <td><code>justify</code></td>
    <td>Параметр <code>justify</code>, установленный для первого символа каждой строки, определяет, как эта строка будет выровнена: <code>tk.LEFT</code> (по умолчанию), <code>tk.CENTER</code> или <code>tk.RIGHT</code>.</td>
  </tr>
  <tr>
    <td><code>lmargin1</code></td>
    <td>На сколько отступать от первой строки фрагмента текста, содержащего этот тег. По умолчанию используется значение <code>0</code>. Допустимые значения см. в <a href="dimensions.html">Раздел 5.1, "Размеры"</a>.</td>
  </tr>
  <tr>
    <td><code>lmargin2</code></td>
    <td>На сколько отступать от последующих строк фрагмента текста, содержащего этот тег. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>offset</code></td>
    <td>На сколько поднимать (положительное значение) или опускать (отрицательное значение) текст с этим тегом относительно базовой линии. Используйте это, например, для получения надстрочных или подстрочных знаков. Допустимые значения см. в <a href="dimensions.html">Раздел 5.1, "Размеры"</a>.</td>
  </tr>
  <tr>
    <td><code>overstrike</code></td>
    <td>Установите <code>overstrike=1</code>, чтобы провести горизонтальную линию через центр текста с этим тегом.</td>
  </tr>
  <tr>
    <td><code>relief</code></td>
    <td>Какой 3-D эффект использовать для текста с этим тегом. По умолчанию используется <code>relief=tk.FLAT</code>; другие возможные значения см. в <a href="relief.html">Раздел 5.6, " Стили рельефа"</a>.</td>
  </tr>
  <tr>
    <td><code>rmargin</code></td>
    <td><a href="dimensions.html">Размер</a> правого поля для фрагментов текста с этим тегом. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>spacing1</code></td>
    <td>Эта опция определяет, сколько дополнительного вертикального <a href="dimensions.html">пространства</a> будет помещено над каждой строкой текста с этим тегом. Если строка переносится, то это пространство добавляется только перед первой строкой, которую она занимает на экране. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>spacing2</code></td>
    <td>Эта опция указывает, сколько дополнительного вертикального пространства добавлять между отображаемыми строками текста с этим тегом, когда строка переносится. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>spacing3</code></td>
    <td>Эта опция определяет, сколько дополнительного вертикального пространства будет добавлено под каждой строкой текста с этим тегом. Если строка переносится, это пространство добавляется только после последней строки, которую она занимает на экране. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>tabs</code></td>
    <td>Как будут развернуты табуляции в строках с этим тегом. См. <a href="text-tabs.html">Раздел 24.6, "Установка табуляции в виджете Text"</a>.</td>
  </tr>
  <tr>
    <td><code>underline</code></td>
    <td>Установите <code>underline=1</code> для подчеркивания текста с помощью этого тега.</td>
  </tr>
  <tr>
    <td><code>wrap</code></td>
    <td>Насколько длинные строки будут перенесены в тексте с этим тегом. См. описание опции <code>wrap</code> для текстовых виджетов <a href="text.html">выше</a>.</td>
  </tr>
  </tbody>
  </table>
</blockquote>

<p><code>.tag_delete(tagName, ...)</code></p>

<blockquote>
  <p>Чтобы удалить один или несколько тегов, передайте их имена в этот метод. Их опции и привязки исчезнут, а теги будут удалены из всех областей текста.</p>
</blockquote>

<p><code>.tag_lower(tagName, belowThis=None)</code></p>

<blockquote>
  <p>Этот метод используется для изменения порядка тегов в стеке тегов (объяснение стека тегов см. в <a href="text-tag.html">разделе 24.5, "Теги виджета Text"</a>, выше). Если вы передадите два аргумента, то тег с именем <code>tagName</code> будет перемещен на позицию чуть ниже тега с именем <code>belowThis</code>. Если вы передадите только один аргумент, то тег будет перемещен в нижнюю часть стека тегов.</p>
</blockquote>

<p><code>.tag_names(index=None)</code></p>

<blockquote>
  <p>Если вы передаете аргумент <code>index</code>, этот метод возвращает последовательность всех имен тегов, которые связаны с символом после этого индекса. Если аргумент не указан, то вы получаете последовательность всех имен тегов, определенных в текстовом виджете.</p>
</blockquote>

<p><code>.tag_nextrange(tagName, index1, index2=None)</code></p>

<blockquote>
  <p>Этот метод ищет места в заданной области, где начинается тег с именем <code>tagName</code>. Искомая область начинается с индекса <code>index1</code> и заканчивается индексом <code>index2</code>. Если аргумент <code>index2</code> опущен, поиск ведется до конца текста.</p>
</blockquote>

<blockquote>
  <p>Если в заданной области с тегом есть место, где он начинается, то метод возвращает последовательность <code>[i0, i1]</code>, где <code>i0</code> - индекс первого помеченного символа, а <code>i1</code> - индекс позиции сразу после последнего помеченного символа.</p>
</blockquote>

<blockquote>
  <p>Если в области не найдено ни одного начала тега, метод возвращает пустую строку.</p>
</blockquote>

<p><code>.tag_prevrange(tagName, index1, index2=None)</code></p>

<blockquote>
  <p>Этот метод ищет места в заданной области, где начинается тег с именем <code>tagName</code>. Область поиска начинается <em>перед</em> индексом <code>index1</code> и заканчивается индексом <code>index2</code>. Если аргумент <code>index2</code> опущен, поиск ведется до конца текста.</p>
</blockquote>

<blockquote>
  <p>Возвращаемые значения такие же, как в <code>.tag_nextrange()</code>.</p>
</blockquote>

<p><code>.tag_raise(tagName, aboveThis=None)</code></p>

<blockquote>
  <p>Используйте этот метод, чтобы изменить порядок тегов в стеке тегов (объяснение стека тегов см. выше, в <a href="text-tag.html">Раздел 24.5, "Теги виджета Text"</a>). Если вы передадите два аргумента, то тег с именем <code>tagName</code> будет перемещен на позицию чуть выше тега с именем <code>aboveThis</code>. Если вы передаете только один аргумент, то этот тег перемещается на вершину стека тегов.</p>
</blockquote>

<p><code>.tag_ranges(tagName)</code></p>

<blockquote>
  <p>Этот метод находит все диапазоны текста в виджете, которые помечены именем <code>tagName</code>, и возвращает последовательность <code>[s0, e0, s1, e1, ...]</code>, где каждый <code>SI</code> - это индекс непосредственно перед первым символом диапазона, а <code>ei</code> - индекс непосредственно после последнего символа диапазона.</p>
</blockquote>

<p><code>.tag_remove(tagName, index1, index2=None)</code></p>

<blockquote>
  <p>Удаляет тег с именем <code>tagName</code> со всех символов между <code>index1</code> и <code>index2</code>. Если <code>index2</code> опущен, то тег удаляется с единственного символа после <code>index1</code>.</p>
</blockquote>

<p><code>.tag_unbind(tagName, sequence, funcid=None)</code></p>

<blockquote>
  <p>Удаляет привязку события для заданной <code>sequence</code> из тега с именем <code>tagName</code>. Если существует несколько обработчиков для данной последовательности и тега, вы можете удалить только один обработчик, передав его в качестве третьего аргумента.</p>
</blockquote>

<p><code>.window_cget(index, option)</code></p>

<blockquote>
  <p>Возвращает значение заданной опции для встроенного виджета по указанному <code>index</code>.</p>
</blockquote>

<p><code>.window_configure(index, option)</code></p>

<blockquote>
  <p>Чтобы изменить значение опций для встроенного виджета в заданном <code>index</code>, передайте одну или несколько пар <code>option=value</code>.</p>
</blockquote>

<blockquote>
  <p>Если вы передадите только один аргумент, то получите словарь, определяющий все опции и их значения, действующие в данный момент для данного виджета.</p>
</blockquote>

<p><code>.window_create(index, option, ...)</code></p>

<blockquote>
  <p>Этот метод создает окно, в котором виджет может быть встроен в текстовый виджет. Существует два способа предоставления встроенного виджета:</p>
</blockquote>

<blockquote>
  <ol>
  <li>Вы можете передать виджет в опцию <code>window</code> в этом методе, или</li>
  </ol>
</blockquote>

<blockquote>
  <ol start="2">
  <li>Можно определить процедуру, которая будет создавать виджет, и передать ее в качестве обратного вызова опции <code>create</code>.</li>
  </ol>
</blockquote>

<blockquote>
  <p>Опциями для <code>.window_create()</code> являются:</p>
</blockquote>

<blockquote>
  <table>
  <thead>
  <tr>
    <th></th>
    <th></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>align</code></td>
    <td>Определяет, как расположить встроенный виджет по вертикали в строке, если он не такой высокий, как текст в строке. Значения включают: <code>align=tk.CENTER</code> (по умолчанию), который центрирует виджет по вертикали в строке; <code>align=tk.TOP</code>, который размещает верх изображения в верхней части строки; <code>align=tk.BOTTOM</code>, который размещает низ изображения в нижней части строки; и <code>align=tk.BASELINE</code>, который выравнивает низ изображения по базовой линии текста.</td>
  </tr>
  <tr>
    <td><code>create</code></td>
    <td>Процедура, создающая встроенный виджет по требованию. Эта процедура не принимает аргументов, должна создавать виджет как дочерний виджет текстового виджета и возвращать виджет в качестве результата.</td>
  </tr>
  <tr>
    <td><code>padx</code></td>
    <td>Дополнительное <a href="dimensions.html">пространство</a>, добавляемое слева и справа от виджета в пределах текстовой строки. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>pady</code></td>
    <td>Дополнительное пространство, добавляемое над и под виджетом в текстовой строке. По умолчанию <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>stretch</code></td>
    <td>Эта опция управляет тем, что происходит, когда строка выше, чем встроенный виджет. Обычно эта опция имеет значение <code>0</code>, что означает, что встроенный виджет будет иметь естественный размер. Если вы установите <code>stretch=1</code>, виджет будет растянут по вертикали, чтобы заполнить высоту строки, а опция <code>align</code> будет проигнорирована.</td>
  </tr>
  <tr>
    <td><code>window</code></td>
    <td>Виджет для вставки. Этот виджет должен быть дочерним по отношению к виджету текста.</td>
  </tr>
  </tbody>
  </table>
</blockquote>

<p><code>.window_names()</code></p>

<blockquote>
  <p>Возвращает последовательность, содержащую имена всех встраиваемых виджетов.</p>
</blockquote>

<p><code>.xview(tk.MOVETO, fraction)</code></p>

<blockquote>
  <p>Этот метод прокручивает текстовый виджет по горизонтали и предназначен для привязки к опции команды связанной горизонтальной полосы прокрутки.</p>
</blockquote>

<blockquote>
  <p>Этот метод может быть вызван двумя разными способами. Первый вызов позиционирует текст на значение, заданное <code>fraction</code>, где 0.0 перемещает текст в крайнее левое положение, а 1.0 - в крайнее правое.</p>
</blockquote>

<p><code>.xview(tk.SCROLL, n, what)</code></p>

<blockquote>
  <p>Второй вызов перемещает текст влево или вправо: аргумент <code>what</code> указывает, на сколько перемещать, и может быть либо <code>tk.UNITS</code>, либо <code>tk.PAGES</code>, а <code>n</code> указывает, на сколько символов или страниц перемещать текст вправо относительно его отображения (или влево, если отрицательно).</p>
</blockquote>

<p><code>.xview_moveto(fraction)</code></p>

<blockquote>
  <p>Этот метод прокручивает текст так же, как и <code>.xview(tk.MOVETO, fraction)</code>.</p>
</blockquote>

<p><code>.xview_scroll(n, what)</code></p>

<blockquote>
  <p>Аналогично <code>.xview(tk.SCROLL, n, what)</code>.</p>
</blockquote>

<p><code>.yview(tk.MOVETO, fraction)</code></p>

<blockquote>
  <p>Эквивалент вертикальной прокрутки <code>.xview(tk.MOVETO,...)</code>.</p>
</blockquote>

<p><code>.yview(tk.SCROLL, n, what)</code></p>

<blockquote>
  <p>Эквивалент вертикальной прокрутки <code>.xview(tk.SCROLL,...)</code>. При вертикальной прокрутке по <code>tk.UNITS</code> единицами измерения являются строки.</p>
</blockquote>

<p><code>.yview_moveto(fraction)</code></p>

<blockquote>
  <p>Эквивалент вертикальной прокрутки <code>.xview_moveto()</code>.</p>
</blockquote>

<p><code>.yview_scroll(n, what)</code></p>

<blockquote>
  <p>Эквивалент вертикальной прокрутки функции <code>.xview_scroll()</code>.</p>
</blockquote>

<hr />

<p><strong><em><a href="toplevel.html">&gt;&gt; Toplevel: Методы окна верхнего уровня</a></em></strong></p>

</body>
</html>
