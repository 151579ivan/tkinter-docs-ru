<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
   <title>Библиотека Tkinter</title>
   <link rel="stylesheet" href="css/xt256.min.css">
   <link rel="stylesheet" href="css/styles.css">
   <script src="css/highlight.min.js"></script>
   <script>hljs.highlightAll();</script>
</head>
<body>

<p><strong><em><a href="index.html">Главная</a></em></strong></p>

<hr />

<h2>Добавление валидации в виджет Entry</h2>

<p>В некоторых приложениях вы захотите проверить содержимое виджета <code>Entry</code>, чтобы убедиться, что оно действительно соответствует какому-то правилу, которое должно соблюдаться в вашем приложении. Вы определяете, что является правильным, написав функцию обратного вызова, которая проверяет содержимое и сигнализирует, является ли оно правильным или нет.</p>

<p>Вот процедура настройки валидации для виджета.</p>

<ol>
<li><p>Напишите функцию обратного вызова, которая проверяет текст в <code>Entry</code> и возвращает <code>True</code>, если текст действителен, или <code>False</code>, если нет. Если обратный вызов возвращает <code>False</code>, попытка пользователя отредактировать текст будет отклонена, и текст останется неизменным.</p></li>
<li><p>Зарегистрируйте функцию обратного вызова. На этом шаге вы создадите Tcl-обертку для функции Python.</p>

<p>Предположим, что ваша функция обратного вызова - это функция с именем <code>isOkay</code>. Чтобы зарегистрировать эту функцию, воспользуйтесь методом из <a href="universal.html">универсальных методов для виджетов</a> <code>.register(isOkay)</code>. Этот метод возвращает символьную строку, которую Tkinter может использовать для вызова вашей функции.</p></li>
<li><p>Когда вы вызываете конструктор <code>Entry</code>, используйте опцию <code>validatecommand</code> в конструкторе <code>Entry</code>, чтобы указать обратный вызов, и опцию <code>validate</code>, чтобы указать, когда будет вызван обратный вызов для проверки текста в обратном вызове. Значения этих опций более подробно рассматриваются ниже.</p></li>
</ol>

<p>Вот значения опции <code>validate</code> и то, что они означают.</p>

<p><code>'focus'</code></p>

<blockquote>
  <p>Проверять всякий раз, когда виджет <code>Entry</code> получает или теряет фокус (см. <a href="focus.html">Раздел 53, "Фокус: маршрутизация ввода с клавиатуры"</a>).</p>
</blockquote>

<p><code>'focusin'</code></p>

<blockquote>
  <p>Проверяет, когда виджет получает фокус.</p>
</blockquote>

<p><code>'focusout'</code></p>

<blockquote>
  <p>Проверяется всякий раз, когда виджет теряет фокус.</p>
</blockquote>

<p><code>'key'</code></p>

<blockquote>
  <p>Проверяет, когда любое нажатие клавиши изменяет содержимое виджета.</p>
</blockquote>

<p><code>'all'</code></p>

<blockquote>
  <p>Проверять во всех вышеперечисленных ситуациях.</p>
</blockquote>

<p><code>'none'</code></p>

<blockquote>
  <p>Отключить валидацию. Это значение опции по умолчанию. Обратите внимание, что это строка <code>'none'</code>, а не специальное значение Python <code>None</code>.</p>
</blockquote>

<p>Значение опции <code>validatecommand</code> зависит от того, какие аргументы вы хотите получить от обратного вызова.</p>

<ul>
<li><p>Возможно, единственное, что нужно знать обратному вызову, это то, какой текст в данный момент отображается в <code>Entry</code>. В этом случае для получения текста можно использовать метод <code>.get()</code> для <code>textvariable</code>, связанной с виджетом.</p>

<p>В этом случае достаточно указать опцию "<code>validatecommand=f</code>", где <code>f</code> - это имя вашей функции обратного вызова.</p></li>
<li><p>Tkinter также может предоставить несколько параметров для обратного вызова. Если вы хотите использовать некоторые из этих параметров, при вызове конструктора <code>Entry</code> используйте опцию <code>validatecommand=(f, s1, s2, ...)</code>, где <code>f</code> - это имя вашей функции обратного вызова, а каждое дополнительное <code>si</code> - это код подстановки. Для каждого кода подстановки, который вы укажете, обратный вызов получит позиционный аргумент, содержащий соответствующее значение.</p></li>
</ul>

<p>Вот коды подстановки.</p>

<p><strong>Таблица 18. Коды подстановки обратного вызова</strong></p>

<table>
<thead>
<tr>
  <th></th>
  <th></th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>'%d'</code></td>
  <td>Код действия: 0 для попытки удаления, 1 для попытки вставки или -1, если обратный вызов был вызван для фокусировки, выхода из фокуса или изменения <code>textvariable</code>.</td>
</tr>
<tr>
  <td><code>'%i'</code></td>
  <td>Когда пользователь пытается вставить или удалить текст, этот аргумент будет индексом начала вставки или удаления. Если обратный вызов был вызван входом в фокус, выходом из фокуса или изменением <code>textvariable</code>, аргумент будет <code>-1</code>.</td>
</tr>
<tr>
  <td><code>'%P'</code></td>
  <td>Значение, которое будет иметь текст, если изменение разрешено.</td>
</tr>
<tr>
  <td><code>'%s'</code></td>
  <td>Текст в Entry перед изменением.</td>
</tr>
<tr>
  <td><code>'%S'</code></td>
  <td>Если вызов был вызван вставкой или удалением, этот аргумент будет текстом, который был вставлен или удален.</td>
</tr>
<tr>
  <td><code>'%v'</code></td>
  <td>Текущее значение опции виджета <code>validate</code>.</td>
</tr>
<tr>
  <td><code>'%V'</code></td>
  <td>Причина этого обратного вызова: одна из <code>'focusin'</code>, <code>'focusout'</code>, <code>'key'</code> или <code>'forced'</code>, если <code>textvariable'</code> была изменена.</td>
</tr>
<tr>
  <td><code>'%W'</code></td>
  <td>Имя виджета.</td>
</tr>
</tbody>
</table>

<p>Вот небольшой пример. Предположим, вы хотите, чтобы ваш обратный вызов получал <code>'%d'</code>, чтобы узнать, почему он был вызван; <code>'%i'</code>, чтобы узнать, где будет происходить вставка или удаление; и <code>'%S'</code>, чтобы узнать, что должно быть вставлено или удалено. Ваш метод может выглядеть следующим образом:</p>

<pre><code>def isOkay(self, why, where, what):
    ...
</code></pre>

<p>Далее вы используете универсальный метод <code>.register()</code>, чтобы обернуть эту функцию. Мы предполагаем, что <code>self</code> - это некоторый виджет.</p>

<pre><code>okayCommand = self.register(isOkay)
</code></pre>

<p>Чтобы установить этот обратный вызов, вы должны использовать эти две опции в конструкторе <code>Entry</code>:</p>

<pre><code>self.w = Entry(self, validate='all', validatecommand=(okayCommand, '%d', '%i', '%S'), ...)
</code></pre>

<p>Предположим, что в данный момент <code>Entry</code> содержит строку <code>'abcdefg'</code>, и пользователь выделяет <code>'cde'</code>, а затем нажимает Backspace. Это приведет к вызову <code>isOkay(0, 2, 'cde')</code>: 0 для удаления, 2 для позиции перед <code>'c'</code>, и <code>'cde'</code> для удаляемой строки. Если <code>isOkay()</code> возвращает <code>True</code>, то новым текстом будет <code>'abfg'</code>; если возвращает <code>False</code>, то текст не изменится.</p>

<p>Виджет <code>Entry</code> также поддерживает опцию <code>invalidcommand</code>, определяющую функцию обратного вызова, которая вызывается всякий раз, когда <code>validatecommand</code> возвращает <code>False</code>. Эта команда может изменять текст в виджете с помощью метода <code>.set()</code> для связанной с виджетом <code>textvariable</code>. Настройка этой опции работает так же, как и настройка <code>validatecommand</code>. Вы должны использовать метод <code>.register()</code> для обертывания вашей функции Python; этот метод возвращает имя обернутой функции в виде строки. Затем вы передадите в качестве значения опции <code>invalidcommand</code> либо эту строку, либо первый элемент кортежа, содержащего коды подстановки.</p>

<hr />

<p><strong><em><a href="frame.html">&gt;&gt; Виджет Frame</a></em></strong></p>

</body>
</html>
